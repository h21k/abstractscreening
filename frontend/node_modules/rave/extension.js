/** @license MIT License (c) copyright 2014 original authors */
/** @author Brian Cavalier */
/** @author John Hann */

exports.load = loadApi;

function loadApi (obj) {

}
/*
An extension needs to do things for several lifecycle stages:

- universal, shared things
	- read context info (debug, options on <html>, etc.)
	- declare namespaces and add properties to context

- load things
	- declare ES6 loader hook overrides:
		- byExtension(s)
		- byPackage(s)
		- byPattern (AMD plugins)
		- combinations of above (e.g. byExtension+byPackage)

- build things
	- In cram, we are able to bundle all types of files into a single file
	  because cram plugins transform files to AMD modules.  We can't assume
	  bundles will be AMD in rave bundles, so we can't use that algorithm.
	- What if load extensions exposed several, optional transform functions?
		- amd.transform(), node.transform(), es.transform()
		- the build extension would choose one of these functions to transform
		  the file into a format it can further transform
	- app-level actions
		- run routine(s) to build files
			- streams. use gulp?
			- files should be transformed by load extensions
			- files that aren't transformed by load extensions should be
 			  prepared by a default transformer (amd, node, es6, globals).
		- move built file(s) to one or more locations(s)
	- load extensions
		- load extensions will have to be modified to return an array
		  of load definitions for each supported module type
		- for each supported module format (amd, node, es):
			- function to prepare (transform) file for a bundle
				- {function transform (source: string): string}
			- expose new pipeline for prepared (transformed) module
				- { normalize, locate, fetch, translate, instantiate }
			- declare other modules that must be included in the bundle
		- format:
		{
			type: string,
			transform: {function (source: string): string},
			hooks: { normalize, locate, fetch, translate, instantiate },
			includes: array<string>
		}
		- example:
		{ type: 'node', hooks: myHooks, transform: toNode, includes: [] }
	- build extensions
		- may need to coordinate with each other. for instance, one may
		  build css and another may build js modules.
		- should not interact with the file system
		- should expose a build function that takes similar options to cram
		  plugins: unnormalized name, referrer name (and url?), a require/import
		  scoped to the referrer, a read function, and error/info/warning
		  functions. this function should return a promise for the transformed
		  file

- deploy things

- test things

*/

return {
	/*
	Load extensions
		- priority
			- packages > pattern > extensions > predicate
			- packages is top priority because each is package is authored
			  separately and package authors (or integrators) know exactly what
			  their package requires.
			- pattern is next since patterns are typically more precise than
			  extensions (which are really just common, simple patterns)
				- plugins are a good example: text!template.html should use
				  a text! plugin, not a text loader pipeline
			- predicate is last to discourage folks from using it since we lose
			  specificity data when they do
		- use cases
			- This 3rd-party package is authored in special XYZ module format.
			- This 3rd-party package uses this version of the text! AMD plugin for templates.
			- This 3rd-party package loads .css files in its own way.
			- My app uses the text! AMD plugin.
			- My app loads .css files via rave-load-css.
			- This package loads off of CDN, not the local file system.
			- I want to apply this cross-cutting transform across all packages.
				- "all packages" is an anti-pattern, specify packages!
		- packages should default to context.app.name
			 - therefore, the packages filter always exists
			 - the more packages, the less specific/priority
		- extensions defaults to [''] (no extension === es module)
			- the more extensions, the less specific/priority
		- pattern defaults to undefined (no pattern)
		- predicate defaults to undefined (no predicate)
	*/

	// organized by feature (feature === collection of predicates/hooks)
	// pro: devs will often approach the problem feature-first
	// con: 99% of the time, there will be only one feature and one package
	load: [
		{
			// all options used
			packages: ['frozen'], // defaults to ["<name of application>"]
			pattern: /!/,
			extensions: ['html', 'text'],
			predicate: function myCondition (arg) {},
			hooks: {
				translate: function () {},
				instantiate: function () {}
			}
		},
		{
			// typical
			packages: ['default'], // default === app?
			extensions: ['html', 'text'],
			hooks: {
				translate: function () {},
				instantiate: function () {}
			}
		}
	],

	// organized by feature, but using a css-like syntax. predicates are moved
	// to top-level of metadata
	// pro: simpler, easier to read for most. no useless array 99% of the time.
	// con: specificity rules and syntax isn't a perfect analog to css.
	// ergo, confusing?
	load2: {
		// all options used
		'myCondition#frozen[pattern="!"].html.text': {
			translate: function () {},
			instantiate: function () {}
		},
		// typical
		// we need a way to specify the app's package. is "default" cool?
		'#default.html.text': {
			translate: function () {},
			instantiate: function () {}
		},
		// alternative that is a bit less css-ish, but doesn't make specificity obvious
		'frozen:.html,.text,/!/': {
			translate: function () {},
			instantiate: function () {}
		}
	},
	myCondition: function (arg) {},

	// organized by package
	// pro: a bit less verbose
	load3: {
		// all options used
		'frozen': {
			pattern: /!/,
			extensions: ['html', 'text'],
			predicate: function myCondition (arg) {},
			hooks: {
				translate: function () {},
				instantiate: function () {}
			}
		},
		// typical
		// we need a way to specify the app's package. is "default" cool?
		'default': {
			extensions: ['html', 'text'],
			hooks: {
				translate: function () {},
				instantiate: function () {}
			}
		}
	},


	/*
	Universal, shared extensions.
		- also need to be organized by package. default = app's package
		- need a better word than "share"?
	*/
	share: {
		'frozen': {
			// This is similar to how the rave-amd-plugins extension shares
			// AMD info already.
			amdPlugins: {
				'text': 'curl/plugin/text'
			}
		}
	}
};
