{"absId":"rave@0.4.3/debug","pluginId":"curl/loader/cjsm11","resourceId":"rave@0.4.3/debug","loader":true,"source":"define('rave@0.4.3/debug',['require','exports','module'],function(require,exports,module,define){/** @license MIT License (c) copyright 2014 original authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\nvar uid = require('./lib/uid');\nvar es5Transform = require('./lib/es5Transform');\nvar metadata = require('./lib/metadata');\n\nmodule.exports = {\n\tstart: startDebug,\n\tassertNoConflicts: detectExtensionConflict,\n\tassertRavePackage: assertRavePackage,\n\tinstallDebugHooks: installDebugHooks,\n\tlogOverrides: logOverrides\n};\n\nvar debugging = \"\\\n┏( ˆ◡ˆ)┛ ┗(ˆ◡ˆ )┓ Welcome to the RaveJS debug party! ┏( ˆ◡ˆ)┛ ┗(ˆ◡ˆ )┓\\n\\\n\\n\\\nIf you see some 404s for JSON files, that's ok! \\\nThey'll go away when you build your app.\\n\\\nIf the 404s are spoiling your debug party, the README.md shows how to \\\nevict them.\\n\";\n\nvar replCommands = \"Available commands:\\n\\\n-> rave.dump() - returns rave's context to be viewed or manipulated.\\n\\\n-> rave.version() - shows rave's version.\\n\\\n-> rave.checkVersions() - checks if extensions are compatible.\\n\\\n-> rave.restore() - restores any previous global rave variable and returns rave\\\n-> rave.help() - shows these commands.\\n\\\n-> what else should we provide? File a github issue!\";\n\nvar replEnabled = \"Rave REPL enabled! (experimental)\\n\"\n\t+ replCommands;\n\nvar multipleRaves = \"Warning: multiple versions of rave are installed. \\\nUpdate the app's dependencies or try the rave.checkVersions() REPL function.\";\n\nvar raveResolution = \"Warning: rave conflict indicated in bower.json. \\\nUpdate the app's dependencies or try the rave.checkVersions() REPL function.\";\n\nvar semverNotInstalled = \"Note: rave.checkVersions() requires the npm semver \\\npackage to verify rave extension semver conflicts. However, the semver \\n\\\npackage isn't needed if you understand semver.\\nTry updating your npm or \\\nbower dependencies.  If updating doesn't resolve the problem, reload \\\nand try rave.checkVersions() again after installing the npm semver package:\\n\\\n$ npm install --save semver\\n\";\n\nvar updateDepsInstructions = \"To update npm dependencies:\\n\\\n$ npm cache clean && npm update && npm dedupe\\n\\\nTo update bower dependencies:\\n\\\n$ bower cache clean && bower update\";\n\nvar semverMissing = \"  ?  {extName} does not specify a rave version. \\\nPlease ask the author to add rave to peerDependencies (npm) or \\\ndependencies (bower). {bugsLink}\";\n\nvar semverValid = \"  ✓  {extName} depends on rave {raveSemver}.\";\n\nvar semverInfo = \"  -  {extName} depends on rave {raveSemver}.\";\n\nvar semverInvalid = \" !!! {extName} depends on rave {raveSemver}. \\\nIf this extension is old, please ask the author to update it. {bugsLink}\";\n\nvar currRaveVersion = \"Rave version is {raveVersion}.\";\n\nvar unknownPackage = \"Unknown package when importing {0} from {1}\\n\\\nDid you forget to specify `--save` when installing?\";\n\nvar wrongModuleType = \"Possible moduleType mismatch? Module {name} appears \\\nto be of type {sourceType}? \\nPlease ask the package author to add or update \\\nmoduleType.\";\n\nvar overriddenPackage = \"Package `{overrider}` overrode metadata properties \\\nof package `{overridee}`.\";\n\nvar defaultedPackage = \"Package `{overrider}` provided default metadata for \\\nmissing properties of package `{overridee}`.\";\n\nvar uniqueThing = {};\n\nfunction startDebug (context) {\n\tvar prev, rave, message;\n\n\tconsole.log(debugging);\n\n\tprev = 'rave' in global ? global.rave : uniqueThing;\n\trave = global.rave = {};\n\n\tmessage = render({}, replEnabled);\n\n\t// TODO: load a debug REPL module?\n\trave.dump = function () {\n\t\treturn context;\n\t};\n\trave.version = function () { return findVersion(context); };\n\trave.checkVersions = function () {\n\t\trunSemverOnExtensions(context);\n\t};\n\trave.help = function () {\n\t\tconsole.log(replCommands);\n\t};\n\trave.restore = function () {\n\t\tif (prev === uniqueThing) {\n\t\t\tdelete global.rave;\n\t\t}\n\t\telse {\n\t\t\tglobal.rave = prev;\n\t\t}\n\t\treturn rave;\n\t};\n\n\tconsole.log(message);\n\n}\n\nfunction assertRavePackage (context) {\n\tif (!('rave' in context.packages)) {\n\t\tthrow new Error('rave package not found.  Did you forget to use --save when installing?');\n\t}\n\treturn context;\n}\n\nfunction installDebugHooks (context) {\n\tvar normalize = context.loader.normalize;\n\t// log an error if rave encounters an unknown package\n\tcontext.loader.normalize = function (name, refName, refUrl) {\n\t\ttry {\n\t\t\tvar normalized = normalize(name, refName, refUrl);\n\t\t}\n\t\tcatch (ex) {\n\t\t\tconsole.error(render(arguments, unknownPackage));\n\t\t\tthrow ex;\n\t\t}\n\t\treturn normalized;\n\t};\n\t// log an error if it looks like an incorrect module type was applied\n\t// override instantiate to catch throws of ReferenceError\n\t// errors can happen when instantiate hook runs (AMD) or when returned factory runs (node)\n\t// if /\\bdefine\\b/ in message, module is AMD, but was not declared as AMD\n\t// if /\\brequire\\b|\\exports\\b|\\bmodule\\b/ in message, module is node, but was not declared as node\n\tvar instantiate = context.loader.instantiate;\n\tcontext.loader.instantiate = function (load) {\n\t\ttry {\n\t\t\treturn Promise.resolve(instantiate(load)).then(createCheckedFactory, checkError);\n\t\t}\n\t\tcatch (ex) {\n\t\t\tcheckError(ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfunction createCheckedFactory (result) {\n\t\t\tvar execute = result.execute;\n\t\t\tif (execute) {\n\t\t\t\tresult.execute = function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn execute.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ex) {\n\t\t\t\t\t\tcheckError(ex);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfunction checkError (ex) {\n\t\t\tvar info = {\n\t\t\t\tname: load.name,\n\t\t\t\tdeclaredType: metadata.findPackage(context.packages, load.name).moduleType\n\t\t\t};\n\t\t\tif (ex instanceof ReferenceError) {\n\t\t\t\tif (!/\\bdefine\\b/.test(ex.message)) {\n\t\t\t\t\tif (/\\brequire\\b|\\exports\\b|\\bmodule\\b/.test(ex.message)) {\n\t\t\t\t\t\tinfo.sourceType = 'node';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinfo.sourceType = 'AMD';\n\t\t\t\t}\n\t\t\t\tif (info.sourceType) {\n\t\t\t\t\tconsole.error(render(info, wrongModuleType));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ex;\n\t\t}\n\t};\n\treturn context;\n}\n\nfunction findVersion (context) {\n\ttry {\n\t\treturn context.packages.rave.metadata.version;\n\t}\n\tcatch (ex) {\n\t\tconsole.error('Rave metadata not found! Did you forget to install rave with the --save option?');\n\t\treturn \"(unknown version)\";\n\t}\n}\n\nfunction render (values, template) {\n\treturn template.replace(/\\{([^\\}]+)\\}/g, function (m, key) {\n\t\treturn values[key];\n\t});\n}\n\nfunction detectExtensionConflict (context) {\n\t// 1. check for more than one rave package. this indicates an npm conflict\n\t// caused by using \"dependencies\" instead of \"peerDependencies\" and\n\t// \"devDependencies\". it could also indicate that the user has installed\n\t// rave via one package manager and extensions via the other.\n\tif (hasMultipleRaves(context)) {\n\t\tconsole.warn(multipleRaves);\n\t\tconsole.log(updateDepsInstructions);\n\t}\n\t// 2. check for resolutions.rave in bower.json which indicates a bower conflict.\n\t// TODO: how do we detect this if the user hasn't chosen to save the resolution?\n\tif (hasRaveResolution(context)) {\n\t\tconsole.warn(raveResolution);\n\t\tconsole.log(updateDepsInstructions);\n\t}\n\treturn context;\n}\n\nfunction hasMultipleRaves (context) {\n\tvar packages, version;\n\tpackages = context.packages;\n\tfor (var name in packages) {\n\t\tif (packages[name].name === 'rave') {\n\t\t\tif (typeof version === 'undefined') {\n\t\t\t\tversion = packages[name].version;\n\t\t\t}\n\t\t\telse if (version !== packages[name].version) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction hasRaveResolution (context) {\n\tvar metadata = context.metadata;\n\tif (metadata) {\n\t\tfor (var i = 0; i < metadata.length; i++) {\n\t\t\tif (metadata.resolutions && metadata.resolutions.rave) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction runSemverOnExtensions (context) {\n\treturn require.async('semver').then(runSemver, noSemver);\n\tfunction runSemver (semver) {\n\t\tvar packages = context.packages;\n\t\tvar seen = {};\n\t\tvar name, pkg, raveSemver, currVer, meta, extName, satisfies, info;\n\t\tcurrVer = findVersion(context);\n\t\tconsole.log(render({ raveVersion: currVer }, currRaveVersion));\n\t\tfor (name in packages) {\n\t\t\tpkg = packages[name];\n\t\t\tif (!(pkg.name in seen)) {\n\t\t\t\tseen[pkg.name] = true;\n\t\t\t\tmeta = pkg.metadata;\n\t\t\t\textName = meta.rave && (typeof meta.rave === 'string'\n\t\t\t\t\t? meta.rave\n\t\t\t\t\t: meta.rave.extension);\n\t\t\t\tif (extName) {\n\t\t\t\t\traveSemver = meta.dependencies && meta.dependencies.rave\n\t\t\t\t\t\t|| meta.peerDependencies && meta.peerDependencies.rave;\n\t\t\t\t\tsatisfies = semver && semver.satisfies(currVer, raveSemver);\n\t\t\t\t\tinfo = {\n\t\t\t\t\t\textName: meta.name,\n\t\t\t\t\t\traveSemver: raveSemver,\n\t\t\t\t\t\tbugsLink: findBugsLink(meta) || ''\n\t\t\t\t\t};\n\t\t\t\t\tif (!raveSemver) {\n\t\t\t\t\t\tconsole.log(render(info, semverMissing));\n\t\t\t\t\t}\n\t\t\t\t\telse if (!semver) {\n\t\t\t\t\t\tconsole.log(render(info, semverInfo));\n\t\t\t\t\t}\n\t\t\t\t\telse if (satisfies) {\n\t\t\t\t\t\tconsole.log(render(info, semverValid));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconsole.log(render(info, semverInvalid));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconsole.log('\\n' + updateDepsInstructions);\n\t}\n\tfunction noSemver () {\n\t\tconsole.log(semverNotInstalled);\n\t\trunSemver();\n\t}\n}\n\nfunction findBugsLink (meta) {\n\tvar link = '';\n\tif (meta.bugs) {\n\t\tlink = typeof meta.bugs === 'string'\n\t\t\t? meta.bugs\n\t\t\t: meta.bugs.url || meta.bugs.email;\n\t}\n\tif (!link && meta.homepage) {\n\t\tlink = meta.homepage;\n\t}\n\tif (!link && meta.maintainers) {\n\t\tlink = findPersonLink(meta.maintainers[0]);\n\t}\n\tif (!link && meta.contributors) {\n\t\tlink = findPersonLink(meta.contributors[0]);\n\t}\n\tif (!link && meta.authors) {\n\t\tlink = findPersonLink(meta.authors[0]);\n\t}\n\tif (!link && meta.author) {\n\t\tlink = findPersonLink(meta.author);\n\t}\n\treturn link;\n}\n\nfunction findPersonLink (person) {\n\tif (typeof person === 'string') {\n\t\treturn person;\n\t}\n\telse {\n\t\treturn person.url || person.web || person.homepage || person.email;\n\t}\n}\n\nfunction logOverrides (context) {\n\tvar seen, name, pkg, extMeta, oname;\n\tseen = {};\n\tfor (name in context.packages) {\n\t\tpkg = context.packages[name];\n\t\t// packages are keyed by versioned and unversioned names\n\t\tif (!(pkg.name in seen) && pkg.metadata && pkg.metadata.rave) {\n\t\t\tseen[pkg.name] = true;\n\t\t\textMeta = pkg.metadata.rave;\n\t\t\t// TODO: ensure that overridee is found\n\t\t\tif (extMeta.missing) {\n\t\t\t\tfor (oname in extMeta.missing) {\n\t\t\t\t\tif (oname in context.packages) {\n\t\t\t\t\t\tconsole.log(render({ overrider: pkg.name, overridee: oname }, defaultedPackage));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (extMeta.overrides) {\n\t\t\t\tfor (oname in extMeta.overrides) {\n\t\t\t\t\tif (oname in context.packages) {\n\t\t\t\t\t\tconsole.log(render({ overrider: pkg.name, overridee: oname }, overriddenPackage));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn context;\n}\n\n});\n\n","modules":[{"pos":0,"count":96,"id":"rave@0.4.3/debug","depList":["require","exports","module"],"factory":true,"argList":["require","exports","module","define"],"requires":[{"id":"rave@0.4.3/lib/uid","pos":226,"count":20},{"id":"rave@0.4.3/lib/es5Transform","pos":267,"count":29},{"id":"rave@0.4.3/lib/metadata","pos":313,"count":25}]}],"compileTime":"2014-11-17T20:58:47.347Z"}